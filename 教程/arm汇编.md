# 汇编

### B-branch（和跳转相关）

B 指令的格式为：    

**B{条件} 目标地址**    

释义：B 指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。    

注意：存储在跳转指令中的值是相对当前PC 值的一个**偏移量**，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB 的地址空间)。

例如以下指令：

B Label ；程序无条件跳转到标号 Label 处执行

​    

### BL 指令

BL 指令的格式为：

**BL{条件} 目标地址**    

释义：BL 是另一个跳转指令，但跳转之前，会在寄存器R14 中保存 PC寄存器（程序计数器） 的当前内容，因此，可以通过将R14 的内容重新加载到PC 中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。以下指令：

BL Label ；当程序无条件跳转到标号 Label 处执行时，同时将当前的 PC 值保存到 R14 中

​    

### BX 指令

BX 指令的格式为：

**BX{条件} 目标地址**     

释义：BX 指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM 指令，也可以是Thumb指令。也就是 arm 指令和 Thumb 指令的相互转换       



### BLX 指令

BLX 指令的格式为：

**BLX 目标地址**    

释义：BLX 指令从ARM 指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM 状态（或者是从 Thumb 指令转换成 ARM 指令）切换到Thumb 状态，该指令同时将PC 的当前内容保存到寄存器R14 中。因此，当子程序使用Thumb 指令集，而调用者使用ARM 指令集时，可以通过BLX 指令实现子程序的调用和处理器工作状态的切换。

同时，子程序的返回可以通过将寄存器R14 值复制到PC 中来完成

---

### LDR，STR（加载，存储）

**加载（load ）就是从 存储器 加载到 寄存器**

**存储（store）就是从 寄存器 取值到 存储器**

寄存器是比内存更加靠近 cpu 的存储介质，加载表示的是，马上要使用该数据，要将该数据存储在寄存器当中等待使用

存储器是用来存储数据处理的结果，自然就是寄存器到存储器

​        

LDR：从存储器中加载数据到寄存器 ← Load from memory into a registor    

LDR R8,[R9,#4]     R8为待加载数据的寄存器，加载值为R9+0x4所指向的存储单元 R8=*(R9+4)    

LDR PC,[SP+4+var_4] 就是将 SP+4+var_4 所指向得数据 丢进 PC 的寄存器当中    

R1 ← [R2]

将 R2 地址所指向的存储器得值 给到 R1 寄存器

​    

STR：将寄存器的数据存储到存储器 → Store from a register into memory STR R8,[R9,#4] 将R8寄存器的数据存储到R9+0x4指向的存储单元  *(R9+4)=R8

R1 → [R2]

将 R1 寄存器的值 给到 存储器 R2 这个地址上

​    

----

### LDM，STM

LDM：将存储器的数据依次加载到一个寄存器列表 → Load from memory into register     

LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器

**千万要注意，这个指令运行的方向和LDR是不一样的，是从左到右运行的**    



其实就是是出栈操作；其中堆栈指针一般对应于SP，注意SP是寄存器R13，实际用到的却是R13中的内存地址，只是该指令没有写为[R13]，同时，LDM指令中寄存器和内存地址的位置相对于前面两条指令改变了，下面的例子：

LDMFD     SP! ,   {R0, R1, R2}

实际上可以理解为：    LDMFD     [SP]!,    {R0, R1, R2}

（sp后面的！，作用是指命令执行完后，对应的地址值赋给sp，对于例程的SDM，是说最后sp的值应该是sp+3*4=sp+12）

​        

STM：将一个寄存器列表的数据存储到指定的存储器

STMFD SP!, {R0}

同样的，该指令也可理解为： STMFD [SP]!, {R0}

意思是：把R0保存到堆栈（sp指向的地址）中。

​    

### PUSH，POP

push 寄存器：将一个寄存器中的数据入栈

pop 寄存器：出栈用一个寄存器接收数据

​    

### MOVE

MOV：将立即数或寄存器的数据传送到目标寄存器 ← MOV R0, #8        R0=8

​    

### 算术运算符

ADD,SUB,MUL,DIV 有符号，无符号运算；带进位运算

​    

### 逻辑运算符

与：AND 全1出1 或：ORR 有1出1 异或：EOR 相同为0，不同为1 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。 但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移← LSR：逻辑右移←

​    

### 比较指令

CMP：比较 CMP R0 #0 		R0寄存器中的值与0比较 标志位：如z位，这个都可以在动态调试时，寄存器窗口看到

​    

### 存储器

存储数据用的，小数据用寄存器，大数据用堆栈

​    

例子：
PUSH  { $R_0$ ~ $R_7$ ，LR} ; 将低寄存器 $R_0$ ~ $R_7$ 全部入栈，LR也入栈

POP { $R_0$ ~ $R_7$ ，PC} ; 将堆栈中的数据弹出到低寄存器 $R_0$ ~ $R_7$ 以及 PC 当中

