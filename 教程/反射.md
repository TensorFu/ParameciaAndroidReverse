## 反射



反射是Java语言的一个功能，它允许程序在运行时动态地访问和操作类和对象。这意味着你可以在程序运行时获取类的信息、创建对象、调用方法、改变字段（属性）等，即使在编写代码时你不知道这些类和对象是什么。

​			

### 能够做什么：

1. **获取类的信息**：反射允许你在运行时了解一个类的结构，包括它的方法、字段、构造函数、注解等。例如，通过类名、对象或者类的全名（字符串形式）来获取`Class`对象。
2. **创建对象实例**：你可以通过反射来创建一个类的实例，即使在编写代码时不知道这个类的具体类型。
3. **调用方法和访问字段**：反射允许你动态地调用任何对象的任何方法，以及访问和修改其字段，即使它们是私有的。



### 一个最简单的案例 -> 反射调用静态的函数

```java
        Class<?> clazz = Class.forName("java.lang.System");  // 获取你想要使用的 class
        Method declaredMethod = clazz.getDeclaredMethod("getProperty",String.class); // 获取你想要的方法，注意：返回的结果是 Method，"getProperty" 就是你调用的函数函数，String.class 就是你的参数的类型，这里注意是，如果你的是多个参数，那么就要写多个，这主要是防止重载。
        Object invoke = DeclaredMethod.invoke(null, "os.arch");  // 这里就是你在调用的函数，传进去的参数。第一个 null ，是所调函数的对象，如果他是静态的，那么就是 null，这里的内容是 null 表明所调用的函数是一个静态函数。 "os.arch" 这个就是传进去的参数
```

​					

```java
Class<?> clazz Class.forname("fullName")
```

来加载对应的类，并将这个类的`Class`对象赋值给`clazz`变量。这个字符串必须是完全限定名（包括包名和类名）。

​						

```java
Class<?> clazz = Class.forname("java.lang.system") 
```

可以使用另一种写法，但是这种写法需要先导入 import 

```java
Class<?> clazz = system.clss;
```

​				

如果你的调用的函数有多个参数，我们就应该这样写：

```java
Method dclaredMethod = clazz.getDeclaredMethod("method",String.class,Int.class,Boolean.class);
```

​			

#### 访问



---

### 反射调用静态函数

```java
package com.open;

public class ExampleClass {
    public static void staticMethod(String message) {
        System.out.println("Static method called with message: " + message);
    }
}
```

​			

```java
import java.lang.reflect.Method;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 获取ExampleClass的Class对象
        Class<?> clazz = Class.forName("com.open.ExampleClass");

        // 获取静态方法staticMethod的Method对象
        Method method = clazz.getDeclaredMethod("staticMethod", String.class);

        // 调用静态方法
        // 因为staticMethod是静态方法，所以invoke方法的第一个参数是null
        method.invoke(null, "Hello, Static Method!");
    }
}
```

​				

-----

### 反射调用实例态函数

```java
package com.open;

public class ExampleClass {
    public void instanceMethod(String message) {
        System.out.println("Instance method called with message: " + message);
    }
}
```



```java
import java.lang.reflect.Method;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 获取ExampleClass的Class对象
        Class<?> clazz = Class.forName("com.open.ExampleClass");

        // 创建ExampleClass的实例
        Object instance = clazz.newInstance();

        // 获取实例方法instanceMethod的Method对象
        Method method = clazz.getDeclaredMethod("instanceMethod", String.class);

        // 调用实例方法
        // 这次需要传入实例对象作为invoke的第一个参数
        method.invoke(instance, "Hello, Instance Method!");
    }
}
```

​				

---

### 访问私有的方法

这里的私有的方法，主要是打开一个开关。

1. 通过`setAccessible(true)`使私有方法可访问

​				

通过反射的方式，访问私有的静态的函数

```java
import java.lang.reflect.Method;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 获取ExampleClass的Class对象
        Class<?> clazz = Class.forName("com.yourpackage.ExampleClass");

        // 获取私有静态方法privateStaticMethod的Method对象
        Method method = clazz.getDeclaredMethod("privateStaticMethod", String.class);

        // 设置为可访问
        method.setAccessible(true);

        // 调用私有静态方法
        // 因为是静态方法，所以invoke的第一个参数是null
        method.invoke(null, "Hello, Private Static Method!");
    }
}
```

​			



```java
import java.lang.reflect.Method;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 获取ExampleClass的Class对象
        Class<?> clazz = Class.forName("com.yourpackage.ExampleClass");

        // 创建ExampleClass的实例
        Object instance = clazz.getDeclaredConstructor().newInstance();

        // 获取私有实例方法privateInstanceMethod的Method对象
        Method method = clazz.getDeclaredMethod("privateInstanceMethod", String.class);

        // 设置为可访问
        method.setAccessible(true);

        // 调用私有实例方法
        method.invoke(instance, "Hello, Private Instance Method!");
    }
}
```





